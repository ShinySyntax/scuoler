{"ast":null,"code":"/*global Blob,File*/\n\n/**\n * Module requirements\n */\nvar isArray = require('isarray');\n\nvar isBuf = require('./is-buffer');\n\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function (packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n\n  return {\n    packet: pack,\n    buffers: buffers\n  };\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = {\n      _placeholder: true,\n      num: buffers.length\n    };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n\n    return newData;\n  }\n\n  return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\n\nexports.reconstructPacket = function (packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\n\nexports.removeBlobs = function (data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj; // convert any blob\n\n    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {\n      pendingBlobs++; // async filereader\n\n      var fileReader = new FileReader();\n\n      fileReader.onload = function () {\n        // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        } else {\n          bloblessData = this.result;\n        } // if nothing pending its callback time\n\n\n        if (! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) {\n      // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) {\n      // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n\n  _removeBlobs(bloblessData);\n\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};","map":{"version":3,"sources":["/home/mathew/javascript/ischools-react/client/node_modules/socket.io-parser/binary.js"],"names":["isArray","require","isBuf","toString","Object","prototype","withNativeBlob","Blob","call","withNativeFile","File","exports","deconstructPacket","packet","buffers","packetData","data","pack","_deconstructPacket","attachments","length","placeholder","_placeholder","num","push","newData","Array","i","Date","key","reconstructPacket","_reconstructPacket","undefined","removeBlobs","callback","_removeBlobs","obj","curKey","containingObject","pendingBlobs","fileReader","FileReader","onload","result","bloblessData","readAsArrayBuffer"],"mappings":"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","sourcesContent":["/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');\nvar withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}