{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar url = require('./url');\n\nvar parser = require('socket.io-parser');\n\nvar Manager = require('./manager');\n\nvar debug = require('debug')('socket.io-client');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = lookup;\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup(uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n\n    io = cache[id];\n  }\n\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n\n  return io.socket(parsed.path, opts);\n}\n/**\n * Protocol version.\n *\n * @api public\n */\n\n\nexports.protocol = parser.protocol;\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');","map":{"version":3,"sources":["/home/mathew/javascript/ischools-react/client/node_modules/socket.io-client/lib/index.js"],"names":["url","require","parser","Manager","debug","module","exports","lookup","cache","managers","uri","opts","undefined","parsed","source","id","path","sameNamespace","nsps","newConnection","forceNew","multiplex","io","query","socket","protocol","connect","Socket"],"mappings":"AACA;;;AAIA,IAAIA,GAAG,GAAGC,OAAO,CAAC,OAAD,CAAjB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,kBAAD,CAApB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,kBAAjB,CAAZ;AAEA;;;;;AAIAI,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGC,MAA3B;AAEA;;;;AAIA,IAAIC,KAAK,GAAGF,OAAO,CAACG,QAAR,GAAmB,EAA/B;AAEA;;;;;;;;;;;;;AAaA,SAASF,MAAT,CAAiBG,GAAjB,EAAsBC,IAAtB,EAA4B;AAC1B,MAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3BC,IAAAA,IAAI,GAAGD,GAAP;AACAA,IAAAA,GAAG,GAAGE,SAAN;AACD;;AAEDD,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AAEA,MAAIE,MAAM,GAAGb,GAAG,CAACU,GAAD,CAAhB;AACA,MAAII,MAAM,GAAGD,MAAM,CAACC,MAApB;AACA,MAAIC,EAAE,GAAGF,MAAM,CAACE,EAAhB;AACA,MAAIC,IAAI,GAAGH,MAAM,CAACG,IAAlB;AACA,MAAIC,aAAa,GAAGT,KAAK,CAACO,EAAD,CAAL,IAAaC,IAAI,IAAIR,KAAK,CAACO,EAAD,CAAL,CAAUG,IAAnD;AACA,MAAIC,aAAa,GAAGR,IAAI,CAACS,QAAL,IAAiBT,IAAI,CAAC,sBAAD,CAArB,IACA,UAAUA,IAAI,CAACU,SADf,IAC4BJ,aADhD;AAGA,MAAIK,EAAJ;;AAEA,MAAIH,aAAJ,EAAmB;AACjBf,IAAAA,KAAK,CAAC,8BAAD,EAAiCU,MAAjC,CAAL;AACAQ,IAAAA,EAAE,GAAGnB,OAAO,CAACW,MAAD,EAASH,IAAT,CAAZ;AACD,GAHD,MAGO;AACL,QAAI,CAACH,KAAK,CAACO,EAAD,CAAV,EAAgB;AACdX,MAAAA,KAAK,CAAC,wBAAD,EAA2BU,MAA3B,CAAL;AACAN,MAAAA,KAAK,CAACO,EAAD,CAAL,GAAYZ,OAAO,CAACW,MAAD,EAASH,IAAT,CAAnB;AACD;;AACDW,IAAAA,EAAE,GAAGd,KAAK,CAACO,EAAD,CAAV;AACD;;AACD,MAAIF,MAAM,CAACU,KAAP,IAAgB,CAACZ,IAAI,CAACY,KAA1B,EAAiC;AAC/BZ,IAAAA,IAAI,CAACY,KAAL,GAAaV,MAAM,CAACU,KAApB;AACD;;AACD,SAAOD,EAAE,CAACE,MAAH,CAAUX,MAAM,CAACG,IAAjB,EAAuBL,IAAvB,CAAP;AACD;AAED;;;;;;;AAMAL,OAAO,CAACmB,QAAR,GAAmBvB,MAAM,CAACuB,QAA1B;AAEA;;;;;;;AAOAnB,OAAO,CAACoB,OAAR,GAAkBnB,MAAlB;AAEA;;;;;;AAMAD,OAAO,CAACH,OAAR,GAAkBF,OAAO,CAAC,WAAD,CAAzB;AACAK,OAAO,CAACqB,MAAR,GAAiB1B,OAAO,CAAC,UAAD,CAAxB","sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar url = require('./url');\nvar parser = require('socket.io-parser');\nvar Manager = require('./manager');\nvar debug = require('debug')('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n  return io.socket(parsed.path, opts);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = require('./manager');\nexports.Socket = require('./socket');\n"]},"metadata":{},"sourceType":"script"}