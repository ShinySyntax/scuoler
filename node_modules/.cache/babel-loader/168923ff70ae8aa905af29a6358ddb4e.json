{"ast":null,"code":"/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\nmodule.exports = function (arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) {\n    return arraybuffer.slice(start, end);\n  }\n\n  if (start < 0) {\n    start += bytes;\n  }\n\n  if (end < 0) {\n    end += bytes;\n  }\n\n  if (end > bytes) {\n    end = bytes;\n  }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n\n  return result.buffer;\n};","map":{"version":3,"sources":["/home/mathew/javascript/ischools-react/client/node_modules/arraybuffer.slice/index.js"],"names":["module","exports","arraybuffer","start","end","bytes","byteLength","slice","ArrayBuffer","abv","Uint8Array","result","i","ii","buffer"],"mappings":"AAAA;;;;;;AAOAA,MAAM,CAACC,OAAP,GAAiB,UAASC,WAAT,EAAsBC,KAAtB,EAA6BC,GAA7B,EAAkC;AACjD,MAAIC,KAAK,GAAGH,WAAW,CAACI,UAAxB;AACAH,EAAAA,KAAK,GAAGA,KAAK,IAAI,CAAjB;AACAC,EAAAA,GAAG,GAAGA,GAAG,IAAIC,KAAb;;AAEA,MAAIH,WAAW,CAACK,KAAhB,EAAuB;AAAE,WAAOL,WAAW,CAACK,KAAZ,CAAkBJ,KAAlB,EAAyBC,GAAzB,CAAP;AAAuC;;AAEhE,MAAID,KAAK,GAAG,CAAZ,EAAe;AAAEA,IAAAA,KAAK,IAAIE,KAAT;AAAiB;;AAClC,MAAID,GAAG,GAAG,CAAV,EAAa;AAAEA,IAAAA,GAAG,IAAIC,KAAP;AAAe;;AAC9B,MAAID,GAAG,GAAGC,KAAV,EAAiB;AAAED,IAAAA,GAAG,GAAGC,KAAN;AAAc;;AAEjC,MAAIF,KAAK,IAAIE,KAAT,IAAkBF,KAAK,IAAIC,GAA3B,IAAkCC,KAAK,KAAK,CAAhD,EAAmD;AACjD,WAAO,IAAIG,WAAJ,CAAgB,CAAhB,CAAP;AACD;;AAED,MAAIC,GAAG,GAAG,IAAIC,UAAJ,CAAeR,WAAf,CAAV;AACA,MAAIS,MAAM,GAAG,IAAID,UAAJ,CAAeN,GAAG,GAAGD,KAArB,CAAb;;AACA,OAAK,IAAIS,CAAC,GAAGT,KAAR,EAAeU,EAAE,GAAG,CAAzB,EAA4BD,CAAC,GAAGR,GAAhC,EAAqCQ,CAAC,IAAIC,EAAE,EAA5C,EAAgD;AAC9CF,IAAAA,MAAM,CAACE,EAAD,CAAN,GAAaJ,GAAG,CAACG,CAAD,CAAhB;AACD;;AACD,SAAOD,MAAM,CAACG,MAAd;AACD,CArBD","sourcesContent":["/**\n * An abstraction for slicing an arraybuffer even when\n * ArrayBuffer.prototype.slice is not supported\n *\n * @api public\n */\n\nmodule.exports = function(arraybuffer, start, end) {\n  var bytes = arraybuffer.byteLength;\n  start = start || 0;\n  end = end || bytes;\n\n  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }\n\n  if (start < 0) { start += bytes; }\n  if (end < 0) { end += bytes; }\n  if (end > bytes) { end = bytes; }\n\n  if (start >= bytes || start >= end || bytes === 0) {\n    return new ArrayBuffer(0);\n  }\n\n  var abv = new Uint8Array(arraybuffer);\n  var result = new Uint8Array(end - start);\n  for (var i = start, ii = 0; i < end; i++, ii++) {\n    result[ii] = abv[i];\n  }\n  return result.buffer;\n};\n"]},"metadata":{},"sourceType":"script"}